<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; }
    body { background: transparent; overflow: hidden; }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
<canvas id="overlay"></canvas>
<script type="module">
import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.mjs";

let handLandmarker = null;
let detectCanvas = null;
let detectCtx = null;
let overlayCanvas = null;
let overlayCtx = null;

// Hand skeleton connections
const HAND_CONNECTIONS = [
  [0, 1], [1, 2], [2, 3], [3, 4],
  [0, 5], [5, 6], [6, 7], [7, 8],
  [0, 9], [9, 10], [10, 11], [11, 12],
  [0, 13], [13, 14], [14, 15], [15, 16],
  [0, 17], [17, 18], [18, 19], [19, 20],
  [5, 9], [9, 13], [13, 17]
];

function drawHands(hands) {
  overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

  for (const hand of hands) {
    const landmarks = hand.landmarks;

    // Draw skeleton lines
    overlayCtx.strokeStyle = '#00ffff';
    overlayCtx.lineWidth = 2;
    for (const [start, end] of HAND_CONNECTIONS) {
      overlayCtx.beginPath();
      overlayCtx.moveTo(landmarks[start].x, landmarks[start].y);
      overlayCtx.lineTo(landmarks[end].x, landmarks[end].y);
      overlayCtx.stroke();
    }

    // Draw landmark dots
    for (let i = 0; i < landmarks.length; i++) {
      const lm = landmarks[i];
      overlayCtx.beginPath();
      overlayCtx.arc(lm.x, lm.y, 4, 0, 2 * Math.PI);
      if (i === 4 || i === 8) {
        overlayCtx.fillStyle = '#ff00ff';
      } else {
        overlayCtx.fillStyle = '#ffff00';
      }
      overlayCtx.fill();
    }

    // Draw pinch distance line
    const thumbTip = landmarks[4];
    const indexTip = landmarks[8];
    overlayCtx.beginPath();
    overlayCtx.moveTo(thumbTip.x, thumbTip.y);
    overlayCtx.lineTo(indexTip.x, indexTip.y);
    overlayCtx.strokeStyle = '#ff00ff';
    overlayCtx.lineWidth = 2;
    overlayCtx.setLineDash([5, 5]);
    overlayCtx.stroke();
    overlayCtx.setLineDash([]);

    // Draw pinch distance text
    const midX = (thumbTip.x + indexTip.x) / 2;
    const midY = (thumbTip.y + indexTip.y) / 2;
    overlayCtx.font = 'bold 14px Arial';
    overlayCtx.fillStyle = '#ff00ff';
    overlayCtx.textAlign = 'center';
    overlayCtx.textBaseline = 'middle';
    overlayCtx.fillText(`${hand.pinchDistance.toFixed(0)}px`, midX, midY - 15);

    // Draw handedness label
    const wrist = landmarks[0];
    overlayCtx.font = 'bold 16px Arial';
    overlayCtx.fillStyle = '#00ffff';
    overlayCtx.fillText(hand.handedness, wrist.x, wrist.y + 20);
  }
}

async function init() {
  try {
    overlayCanvas = document.getElementById('overlay');
    overlayCtx = overlayCanvas.getContext('2d');

    detectCanvas = document.createElement('canvas');
    detectCtx = detectCanvas.getContext('2d');

    const vision = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
    );

    handLandmarker = await HandLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO",
      numHands: 2,
      minHandDetectionConfidence: 0.5,
      minHandPresenceConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    parent.postMessage({ type: 'ready' }, '*');
  } catch (err) {
    console.error('Failed to initialize HandLandmarker:', err);
    parent.postMessage({ type: 'error', error: err.message }, '*');
  }
}

function detect(imageData, width, height, requestId) {
  if (!handLandmarker) {
    parent.postMessage({ type: 'result', requestId, hands: [] }, '*');
    return;
  }

  // Resize canvases if needed
  if (detectCanvas.width !== width || detectCanvas.height !== height) {
    detectCanvas.width = width;
    detectCanvas.height = height;
    overlayCanvas.width = width;
    overlayCanvas.height = height;
  }

  // Draw image data to detection canvas
  const imgData = new ImageData(new Uint8ClampedArray(imageData), width, height);
  detectCtx.putImageData(imgData, 0, 0);

  // Detect hands using VIDEO mode (tracks between frames)
  const results = handLandmarker.detectForVideo(detectCanvas, performance.now());

  if (!results || !results.landmarks || results.landmarks.length === 0) {
    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
    parent.postMessage({ type: 'result', requestId, hands: [] }, '*');
    return;
  }

  const hands = [];
  for (let i = 0; i < results.landmarks.length; i++) {
    const landmarks = results.landmarks[i];
    const handedness = results.handednesses[i]?.[0]?.categoryName || 'Unknown';

    const pixelLandmarks = landmarks.map(lm => ({
      x: lm.x * width,
      y: lm.y * height,
      z: lm.z * width
    }));

    const thumbTip = pixelLandmarks[4];
    const indexTip = pixelLandmarks[8];
    const pinchDistance = Math.sqrt(
      Math.pow(thumbTip.x - indexTip.x, 2) +
      Math.pow(thumbTip.y - indexTip.y, 2) +
      Math.pow(thumbTip.z - indexTip.z, 2)
    );

    hands.push({
      landmarks: pixelLandmarks,
      pinchDistance: pinchDistance,
      handedness: handedness
    });
  }

  // Draw hands on overlay canvas inside iframe
  drawHands(hands);

  parent.postMessage({ type: 'result', requestId, hands }, '*');
}

window.addEventListener('message', (event) => {
  if (event.data.type === 'detect') {
    detect(event.data.imageData, event.data.width, event.data.height, event.data.requestId);
  } else if (event.data.type === 'resize') {
    overlayCanvas.width = event.data.width;
    overlayCanvas.height = event.data.height;
  }
});

init();
</script>
</body>
</html>
